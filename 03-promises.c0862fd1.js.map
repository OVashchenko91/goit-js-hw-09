{"mappings":"gfACAA,EAAA,SAGmL,IAA7KC,EAAOC,SAASC,cAAc,SAE9BC,EAAaF,SAASC,cAAc,kBACpCE,EAAOH,SAASC,cAAc,iBAC9BG,EAASJ,SAASC,cAAc,mBAEtCF,EAAKM,iBAAiB,UAEgC,SAA9BC,G,kBAiBxB,IAAuBC,EAAUC,GAAVD,EAXLE,EAWeD,EAXZE,EAYZ,IAAIC,SAAQ,SAACC,EAASC,GAC3BC,YAAW,WACaC,KAAKC,SAAW,GAEpCJ,EAAQ,CAAEL,WAAUC,UAEpBK,EAAO,CAAEN,WAAUC,S,GAEpBA,E,KAnB0ES,MAArE,SAAAC,GAAWA,EAARX,S,IAAUC,EAAKU,EAALV,MACjBW,OAAOC,QAAQ,uBAAiCC,OAARZ,EAAE,QAAYY,OAANb,EAAM,M,IAEvDc,OAAM,SAAAJ,GAAWA,EAARX,S,IAAUC,EAAKU,EAALV,MAClBW,OAAOI,QAAQ,sBAAgCF,OAARZ,EAAE,QAAYY,OAANb,EAAM,M,IAEzDE,GAASP,EAAKqB,a,EAZhBlB,EAAEmB,iBAIF,IAFA,IAAIf,EAAQR,EAAWsB,cAEdE,EAAI,EAAGA,GAAKtB,EAAOoB,cAAeE,GAAK,EAACC,EAAAD,E","sources":["src/js/03-promises.js"],"sourcesContent":["\nimport Notiflix from 'notiflix';//використовується для відображення сповіщень про успішне та невдале виконання в браузері\n\n//визначає елемент форми з назвою класу \"form\" і вибирає три елементи введення з іменами \"delay\", \"step\" і \"amount\" за допомогою методу querySelector. Ці вхідні елементи використовуються для налаштування промісів, які будуть створені та вирішені або відхилені.\nconst form = document.querySelector('.form');\n\nconst firstDelay = document.querySelector('[name=\"delay\"]');\nconst step = document.querySelector('[name=\"step\"]');\nconst amount = document.querySelector('[name=\"amount\"]');\n\nform.addEventListener('submit', submitPromises);//прикріплює слухач подій до елемента форми для події надсилання\n\nfunction submitPromises(e) {//Коли форма надсилається, викликається функція 'submitPromises'. Ця функція запобігає поведінці надсилання форми за допомогою «e.preventDefault», а потім ініціалізує змінну «delay» значенням вхідного елемента «firstDelay»\n  e.preventDefault();\n\n  let delay = firstDelay.valueAsNumber;\n\n  for (let i = 1; i <= amount.valueAsNumber; i += 1) {// цикл виконується ? разів, щоразу створюючи новий Promise за допомогою функції «createPromise».\n    createPromise(i, delay) //створює Promise, який вирішує або відхиляє випадковим чином після затримки, визначеної змінною 'delay'.\n      .then(({ position, delay }) => {//для кожного створеного Promise викликається метод then із функцією зворотного виклику успіху, яка відображає сповіщення про успіх за допомогою об’єкта Notify\n        Notify.success(`✅ Fulfilled promise ${i} in ${delay}ms`);\n      })\n      .catch(({ position, delay }) => {//метод catch викликається функцією зворотного виклику помилки, яка відображає сповіщення про помилку за допомогою об’єкта Notify\n        Notify.failure(`❌ Rejected promise ${i} in ${delay}ms`);\n      });\n    delay += step.valueAsNumber; //змінна «delay» збільшується на значення вхідного елемента «step» у кожній ітерації циклу, так що кожен проміс створюється з більшою затримкою, ніж попередня\n  }\n}\n\nfunction createPromise(position, delay) { //призначена для повернення нового промісу, який вирішується або відхиляється після визначеної затримки за допомогою методу setTimeout. Проміс вирішується або відхиляється на основі випадково згенерованого значення, яке визначає, чи потрібно виконати проміс чи відхилити.\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const shouldResolve = Math.random() > 0.3;\n      if (shouldResolve) {\n        resolve({ position, delay });\n      } else {\n        reject({ position, delay });\n      }\n    }, delay);\n  });\n}"],"names":["parcelRequire","$ce04d3a99e08e73b$var$form","document","querySelector","$ce04d3a99e08e73b$var$firstDelay","$ce04d3a99e08e73b$var$step","$ce04d3a99e08e73b$var$amount","addEventListener","e","position","delay","i","delay1","Promise","resolve","reject","setTimeout","Math","random","then","param","Notify","success","concat","catch","failure","valueAsNumber","preventDefault","i1","_loop"],"version":3,"file":"03-promises.c0862fd1.js.map"}